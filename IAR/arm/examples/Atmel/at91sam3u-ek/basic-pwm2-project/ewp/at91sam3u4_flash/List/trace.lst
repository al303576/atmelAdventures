###############################################################################
#                                                                             #
#                                                       28/Feb/2012  20:28:09 #
# IAR ANSI C/C++ Compiler V6.30.6.33336/W32 KICKSTART for ARM                 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91lib\utility\trace.c                         #
#    Command line =  C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91lib\utility\trace.c -D at91sam3u4 -D flash  #
#                    -D TRACE_LEVEL=4 -lC C:\Users\Martin\Documents\AtmelAdve #
#                    ntures\IAR\arm\examples\Atmel\at91sam3u-ek\basic-pwm2-pr #
#                    oject\ewp\at91sam3u4_flash\List\ --remarks               #
#                    --diag_suppress Pe826,Pe1375 -o                          #
#                    C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\at91sam3u4_ #
#                    flash\Obj\ --debug --endian=little --cpu=Cortex-M3 -e    #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0                           #
#                    Kickstart_2\arm\INC\c\DLib_Config_Full.h" -I             #
#                    C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\..\..\..\at #
#                    91lib/peripherals\ -I C:\Users\Martin\Documents\AtmelAdv #
#                    entures\IAR\arm\examples\Atmel\at91sam3u-ek\basic-pwm2-p #
#                    roject\ewp\..\..\..\at91lib/components\ -I               #
#                    C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\..\..\..\at #
#                    91lib\ -I C:\Users\Martin\Documents\AtmelAdventures\IAR\ #
#                    arm\examples\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\. #
#                    .\..\..\external_libs\ -I C:\Users\Martin\Documents\Atme #
#                    lAdventures\IAR\arm\examples\Atmel\at91sam3u-ek\basic-pw #
#                    m2-project\ewp\..\..\..\at91lib/boards/at91sam3u-ek\     #
#                    -Ohz --use_c++_inline                                    #
#    List file    =  C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\at91sam3u4_ #
#                    flash\List\trace.lst                                     #
#    Object file  =  C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\at91sam3u4_ #
#                    flash\Obj\trace.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\examples\Atmel\at91lib\utility\trace.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          
     31          //------------------------------------------------------------------------------
     32          //         Headers
     33          //------------------------------------------------------------------------------
     34          
     35          #include "trace.h"
     36          
     37          //------------------------------------------------------------------------------
     38          //         Internal variables
     39          //------------------------------------------------------------------------------
     40          
     41          /// Trace level can be set at applet initialization
     42          #if !defined(NOTRACE) && (DYN_TRACES == 1)
     43              unsigned int traceLevel = TRACE_LEVEL;
     44          #endif
     45            
     46          #ifndef NOFPUT
     47          #include <stdio.h>
     48          #include <stdarg.h>
     49          
     50          //------------------------------------------------------------------------------
     51          /// \exclude
     52          /// Implementation of fputc using the DBGU as the standard output. Required
     53          /// for printf().
     54          /// \param c  Character to write.
     55          /// \param pStream  Output stream.
     56          /// \param The character written if successful, or -1 if the output stream is
     57          /// not stdout or stderr.
     58          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     59          signed int fputc(signed int c, FILE *pStream)
     60          {
   \                     fputc:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     61              if ((pStream == stdout) || (pStream == stderr)) {
   \   00000004   0x....             LDR.N    R0,??DataTable8_5
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xBF1C             ITT      NE 
   \   0000000A   0x....             LDRNE.N  R0,??DataTable8_6
   \   0000000C   0x4281             CMPNE    R1,R0
   \   0000000E   0xD104             BNE.N    ??fputc_0
     62          
     63                  TRACE_PutChar(c);
   \   00000010   0xB2E0             UXTB     R0,R4
   \   00000012   0x.... 0x....      BL       DBGU_PutChar
     64                  return c;
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xBD10             POP      {R4,PC}
     65              }
     66              else {
     67          
     68                  return EOF;
   \                     ??fputc_0:
   \   0000001A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
     69              }
     70          }
     71          
     72          //------------------------------------------------------------------------------
     73          /// \exclude
     74          /// Implementation of fputs using the DBGU as the standard output. Required
     75          /// for printf(). Does NOT currently use the PDC.
     76          /// \param pStr  String to write.
     77          /// \param pStream  Output stream.
     78          /// \return Number of characters written if successful, or -1 if the output
     79          /// stream is not stdout or stderr.
     80          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     81          signed int fputs(const char *pStr, FILE *pStream)
     82          {
   \                     fputs:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
     83              signed int num = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE000             B.N      ??fputs_0
     84          
     85              while (*pStr != 0) {
     86          
     87                  if (fputc(*pStr, pStream) == -1) {
     88          
     89                      return -1;
     90                  }
     91                  num++;
   \                     ??fputs_1:
   \   0000000A   0x1C76             ADDS     R6,R6,#+1
     92                  pStr++;
   \                     ??fputs_0:
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0xB150             CBZ.N    R0,??fputs_2
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000016   0x.... 0x....      BL       fputc
   \   0000001A   0xF110 0x0F01      CMN      R0,#+1
   \   0000001E   0xD1F4             BNE.N    ??fputs_1
   \   00000020   0xF04F 0x30FF      MOV      R0,#-1
   \   00000024   0xBD70             POP      {R4-R6,PC}
     93              }
     94          
     95              return num;
   \                     ??fputs_2:
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
     96          }
     97          
     98          #undef putchar
     99          
    100          //------------------------------------------------------------------------------
    101          /// \exclude
    102          /// Outputs a character on the DBGU.
    103          /// \param c  Character to output.
    104          /// \return The character that was output.
    105          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    106          signed int putchar(signed int c)
    107          {
    108              return fputc(c, stdout);
   \                     putchar:
   \   00000000   0x....             LDR.N    R1,??DataTable8_5
   \   00000002   0x....             B.N      fputc
    109          }
    110          
    111          #endif //#ifndef NOFPUT
    112          
    113          //------------------------------------------------------------------------------
    114          //         Local Functions
    115          //------------------------------------------------------------------------------
    116          
    117          //------------------------------------------------------------------------------
    118          /// Print char if printable. If not print a point
    119          /// \param c char to
    120          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    121          static void PrintChar(unsigned char c)
    122          {
    123              if( (/*c >= 0x00 &&*/ c <= 0x1F) ||
    124                  (c >= 0xB0 && c <= 0xDF) ) {
   \                     PrintChar:
   \   00000000   0x2820             CMP      R0,#+32
   \   00000002   0xBF22             ITTT     CS 
   \   00000004   0xF100 0x0150      ADDCS    R1,R0,#+80
   \   00000008   0xB2C9             UXTBCS   R1,R1
   \   0000000A   0x2930             CMPCS    R1,#+48
   \   0000000C   0xBF3C             ITT      CC 
   \   0000000E   0x....             ADRCC.N  R0,??DataTable8  ;; "."
   \   00000010   0x.... 0x....      BCC.W    printf
    125          
    126                 printf(".");
    127              }
    128              else {
    129          
    130                 printf("%c", c);
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x....             ADR.N    R0,??DataTable8_1  ;; 0x25, 0x63, 0x00, 0x00
   \   00000018   0x.... 0x....      B.W      printf
    131              }
    132          }
    133          
    134          //------------------------------------------------------------------------------
    135          //         Global Functions
    136          //------------------------------------------------------------------------------
    137          
    138          //------------------------------------------------------------------------------
    139          /// Displays the content of the given frame on the Trace interface.
    140          /// \param pBuffer  Pointer to the frame to dump.
    141          /// \param size  Buffer size in bytes.
    142          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    143          void TRACE_DumpFrame(unsigned char *pFrame, unsigned int size)
    144          {
   \                     TRACE_DumpFrame:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    145              unsigned int i;
    146          
    147              for (i=0; i < size; i++) {
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x....             LDR.N    R7,??DataTable8_7
   \   0000000A   0xE004             B.N      ??TRACE_DumpFrame_0
    148                  printf("%02X ", pFrame[i]);
   \                     ??TRACE_DumpFrame_1:
   \   0000000C   0x5D31             LDRB     R1,[R6, R4]
   \   0000000E   0x4638             MOV      R0,R7
   \   00000010   0x.... 0x....      BL       printf
    149              }
   \   00000014   0x1C76             ADDS     R6,R6,#+1
   \                     ??TRACE_DumpFrame_0:
   \   00000016   0x42AE             CMP      R6,R5
   \   00000018   0xD3F8             BCC.N    ??TRACE_DumpFrame_1
    150          
    151              printf("\n\r");
   \   0000001A   0x....             ADR.N    R0,??DataTable8_2  ;; 0x0A, 0x0D, 0x00, 0x00
   \   0000001C   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000020   0x.... 0x....      B.W      printf
    152          }
    153          
    154          //------------------------------------------------------------------------------
    155          /// Displays the content of the given buffer on the Trace interface.
    156          /// \param pBuffer  Pointer to the buffer to dump.
    157          /// \param size     Buffer size in bytes.
    158          /// \param address  Start address to display
    159          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    160          void TRACE_DumpMemory(
    161              unsigned char *pBuffer,
    162              unsigned int size,
    163              unsigned int address
    164              )
    165          {
   \                     TRACE_DumpMemory:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4616             MOV      R6,R2
    166              unsigned int i, j;
    167              unsigned int lastLineStart;
    168              unsigned char* pTmp;
    169          
    170              for (i=0; i < (size / 16); i++) {
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0x.... 0x....      LDR.W    R10,??DataTable8_8
   \   00000010   0xE020             B.N      ??TRACE_DumpMemory_0
    171          
    172                  printf("0x%08X: ", address + (i*16));
   \                     ??TRACE_DumpMemory_1:
   \   00000012   0xEB16 0x1104      ADDS     R1,R6,R4, LSL #+4
   \   00000016   0x4650             MOV      R0,R10
   \   00000018   0x.... 0x....      BL       printf
    173                  pTmp = (unsigned char*)&pBuffer[i*16];
   \   0000001C   0xEB08 0x1504      ADD      R5,R8,R4, LSL #+4
   \   00000020   0x462F             MOV      R7,R5
    174                  for (j=0; j < 4; j++) {
   \   00000022   0xF04F 0x0B04      MOV      R11,#+4
    175                      printf("%02X%02X%02X%02X ", pTmp[0],pTmp[1],pTmp[2],pTmp[3]);
   \                     ??TRACE_DumpMemory_2:
   \   00000026   0x78F8             LDRB     R0,[R7, #+3]
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x78BB             LDRB     R3,[R7, #+2]
   \   0000002C   0x787A             LDRB     R2,[R7, #+1]
   \   0000002E   0xF817 0x1B04      LDRB     R1,[R7], #+4
   \   00000032   0xF10A 0x000C      ADD      R0,R10,#+12
   \   00000036   0x.... 0x....      BL       printf
    176                      pTmp += 4;
    177                  }
   \   0000003A   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   0000003E   0xD1F2             BNE.N    ??TRACE_DumpMemory_2
    178          
    179                  pTmp = (unsigned char*)&pBuffer[i*16];
    180                  for (j=0; j < 16; j++) {
   \   00000040   0x2710             MOVS     R7,#+16
    181                      PrintChar(*pTmp++);
   \                     ??TRACE_DumpMemory_3:
   \   00000042   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   00000046   0x.... 0x....      BL       PrintChar
    182                  }
   \   0000004A   0x1E7F             SUBS     R7,R7,#+1
   \   0000004C   0xD1F9             BNE.N    ??TRACE_DumpMemory_3
    183          
    184                  printf("\n\r");
   \   0000004E   0x.... 0x....      BL       ?Subroutine0
    185              }
   \                     ??CrossCallReturnLabel_3:
   \   00000052   0x1C64             ADDS     R4,R4,#+1
   \                     ??TRACE_DumpMemory_0:
   \   00000054   0xEBB4 0x1F19      CMP      R4,R9, LSR #+4
   \   00000058   0xD3DB             BCC.N    ??TRACE_DumpMemory_1
    186          
    187              if( (size%16) != 0) {
   \   0000005A   0xF019 0x000F      ANDS     R0,R9,#0xF
   \   0000005E   0xD032             BEQ.N    ??TRACE_DumpMemory_4
    188                  lastLineStart = size - (size%16);
   \   00000060   0xEBA9 0x0400      SUB      R4,R9,R0
    189                  printf("0x%08X: ", address + lastLineStart);
   \   00000064   0x19A1             ADDS     R1,R4,R6
   \   00000066   0x4650             MOV      R0,R10
   \   00000068   0x.... 0x....      BL       printf
    190          
    191                  for (j= lastLineStart; j < lastLineStart+16; j++) {
   \   0000006C   0x4627             MOV      R7,R4
   \   0000006E   0x....             ADR.N    R6,??DataTable8_3  ;; 0x20, 0x20, 0x00, 0x00
   \   00000070   0x....             ADR.N    R5,??DataTable8_4  ;; " "
   \   00000072   0xE003             B.N      ??TRACE_DumpMemory_5
    192          
    193                      if( (j!=lastLineStart) && (j%4 == 0) ) {
    194                          printf(" ");
    195                      }
    196                      if(j<size) {
    197                          printf("%02X", pBuffer[j]);
    198                      }
    199                      else {
    200                          printf("  ");
   \                     ??TRACE_DumpMemory_6:
   \   00000074   0x4630             MOV      R0,R6
   \   00000076   0x.... 0x....      BL       printf
    201                      }
   \                     ??TRACE_DumpMemory_7:
   \   0000007A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??TRACE_DumpMemory_5:
   \   0000007C   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000080   0x4287             CMP      R7,R0
   \   00000082   0xD210             BCS.N    ??TRACE_DumpMemory_8
   \   00000084   0x42A7             CMP      R7,R4
   \   00000086   0xD005             BEQ.N    ??TRACE_DumpMemory_9
   \   00000088   0xF017 0x0003      ANDS     R0,R7,#0x3
   \   0000008C   0xBF04             ITT      EQ 
   \   0000008E   0x4628             MOVEQ    R0,R5
   \   00000090   0x.... 0x....      BLEQ     printf
   \                     ??TRACE_DumpMemory_9:
   \   00000094   0x454F             CMP      R7,R9
   \   00000096   0xD2ED             BCS.N    ??TRACE_DumpMemory_6
   \   00000098   0xF817 0x1008      LDRB     R1,[R7, R8]
   \   0000009C   0xF10A 0x0020      ADD      R0,R10,#+32
   \   000000A0   0x.... 0x....      BL       printf
   \   000000A4   0xE7E9             B.N      ??TRACE_DumpMemory_7
    202                  }
    203          
    204                  printf(" ");
   \                     ??TRACE_DumpMemory_8:
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0x.... 0x....      BL       printf
    205                  for (j= lastLineStart; j <size; j++) {
   \   000000AC   0xE004             B.N      ??TRACE_DumpMemory_10
    206                      PrintChar(pBuffer[j]);
   \                     ??TRACE_DumpMemory_11:
   \   000000AE   0xF814 0x0008      LDRB     R0,[R4, R8]
   \   000000B2   0x.... 0x....      BL       PrintChar
    207                  }
   \   000000B6   0x1C64             ADDS     R4,R4,#+1
   \                     ??TRACE_DumpMemory_10:
   \   000000B8   0x454C             CMP      R4,R9
   \   000000BA   0xD3F8             BCC.N    ??TRACE_DumpMemory_11
    208          
    209                  printf("\n\r");
   \   000000BC   0x....             ADR.N    R0,??DataTable8_2  ;; 0x0A, 0x0D, 0x00, 0x00
   \   000000BE   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \   000000C2   0x.... 0x....      B.W      printf
    210              }
    211          }
   \                     ??TRACE_DumpMemory_4:
   \   000000C6   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x....             ADR.N    R0,??DataTable8_2  ;; 0x0A, 0x0D, 0x00, 0x00
   \   00000002   0x.... 0x....      B.W      printf
    212              
    213          //------------------------------------------------------------------------------
    214          /// Reads an integer
    215          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    216          unsigned char TRACE_GetInteger(unsigned int *pValue)
    217          {
   \                     TRACE_GetInteger:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    218              unsigned char key;
    219              unsigned char nbNb = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    220              unsigned int value = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE005             B.N      ??TRACE_GetInteger_0
    221              while(1) {
    222                  key = TRACE_GetChar();
    223                  TRACE_PutChar(key);
    224                  if(key >= '0' &&  key <= '9' ) {
    225                      value = (value * 10) + (key - '0');
   \                     ??TRACE_GetInteger_1:
   \   0000000A   0x200A             MOVS     R0,#+10
   \   0000000C   0xFB00 0x7006      MLA      R0,R0,R6,R7
   \   00000010   0xF1A0 0x0630      SUB      R6,R0,#+48
    226                      nbNb++;
   \   00000014   0x1C6D             ADDS     R5,R5,#+1
    227                  }
   \                     ??TRACE_GetInteger_0:
   \   00000016   0x.... 0x....      BL       DBGU_GetChar
   \   0000001A   0x4607             MOV      R7,R0
   \   0000001C   0x.... 0x....      BL       DBGU_PutChar
   \   00000020   0xF1A7 0x0030      SUB      R0,R7,#+48
   \   00000024   0x280A             CMP      R0,#+10
   \   00000026   0xD3F0             BCC.N    ??TRACE_GetInteger_1
    228                  else if(key == 0x0D || key == ' ') {
   \   00000028   0x....             LDR.N    R0,??DataTable8_9
   \   0000002A   0x2F0D             CMP      R7,#+13
   \   0000002C   0xBF18             IT       NE 
   \   0000002E   0x2F20             CMPNE    R7,#+32
   \   00000030   0xD109             BNE.N    ??TRACE_GetInteger_2
    229                      if(nbNb == 0) {
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0xB915             CBNZ.N   R5,??TRACE_GetInteger_3
    230                          printf("\n\rWrite a number and press ENTER or SPACE!\n\r");       
   \   00000036   0x.... 0x....      BL       printf
    231                          return 0; 
   \   0000003A   0xE008             B.N      ??TRACE_GetInteger_4
    232                      } else {
    233                          printf("\n\r"); 
   \                     ??TRACE_GetInteger_3:
   \   0000003C   0x.... 0x....      BL       ?Subroutine0
    234                          *pValue = value;
   \                     ??CrossCallReturnLabel_2:
   \   00000040   0x6026             STR      R6,[R4, #+0]
    235                          return 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}
    236                      }
    237                  } else {
    238                      printf("\n\r'%c' not a number!\n\r", key);
   \                     ??TRACE_GetInteger_2:
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x3030             ADDS     R0,R0,#+48
   \   0000004A   0x.... 0x....      BL       printf
    239                      return 0;  
   \                     ??TRACE_GetInteger_4:
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    240                  }
    241              }
    242          }
    243          
    244          //------------------------------------------------------------------------------
    245          /// Reads an integer and check the value
    246          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    247          unsigned char TRACE_GetIntegerMinMax(
    248              unsigned int *pValue, 
    249              unsigned int min, 
    250              unsigned int max
    251              )
    252          {
   \                     TRACE_GetIntegerMinMax:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    253              unsigned int value = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    254          
    255              if( TRACE_GetInteger(&value) == 0) {
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      BL       TRACE_GetInteger
   \   00000014   0xB180             CBZ.N    R0,??TRACE_GetIntegerMinMax_0
    256                  return 0;
    257              }
    258              
    259              if(value < min || value > max) {
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x42A8             CMP      R0,R5
   \   0000001A   0xBF28             IT       CS 
   \   0000001C   0x4286             CMPCS    R6,R0
   \   0000001E   0xD206             BCS.N    ??TRACE_GetIntegerMinMax_1
    260                  printf("\n\rThe number have to be between %d and %d\n\r", min, max);
                                                                                   ^
Remark[Pe181]: argument is incompatible with corresponding format string
          conversion

          printf("\n\rThe number have to be between %d and %d\n\r", min, max);
                                                                         ^
"C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\examples\Atmel\at91lib\utility\trace.c",260  Remark[Pe181]: 
          argument is incompatible with corresponding format string conversion
   \   00000020   0x4632             MOV      R2,R6
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x....             LDR.N    R0,??DataTable8_10
   \   00000026   0x.... 0x....      BL       printf
    261                  return 0; 
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD76             POP      {R1,R2,R4-R6,PC}
    262              }
    263          
    264              printf("\n\r"); 
   \                     ??TRACE_GetIntegerMinMax_1:
   \   0000002E   0x.... 0x....      BL       ?Subroutine0
    265              *pValue = value;
   \                     ??CrossCallReturnLabel_1:
   \   00000032   0x9800             LDR      R0,[SP, #+0]
   \   00000034   0x6020             STR      R0,[R4, #+0]
    266              return 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \                     ??TRACE_GetIntegerMinMax_0:
   \   00000038   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    267          }
    268          
    269          //------------------------------------------------------------------------------
    270          /// Reads an hexadecimal number
    271          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    272          unsigned char TRACE_GetHexa32(unsigned int *pValue)
    273          {
   \                     TRACE_GetHexa32:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    274              unsigned char key;
    275              unsigned int i = 0;
    276              unsigned int value = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    277              for(i = 0; i < 8; i++) {
   \   00000006   0x2608             MOVS     R6,#+8
    278                  key = TRACE_GetChar();
   \                     ??TRACE_GetHexa32_0:
   \   00000008   0x.... 0x....      BL       DBGU_GetChar
   \   0000000C   0x4607             MOV      R7,R0
    279                  TRACE_PutChar(key);
   \   0000000E   0x.... 0x....      BL       DBGU_PutChar
    280                  if(key >= '0' &&  key <= '9' ) {
   \   00000012   0xEB07 0x1005      ADD      R0,R7,R5, LSL #+4
   \   00000016   0xF1A7 0x0130      SUB      R1,R7,#+48
   \   0000001A   0x290A             CMP      R1,#+10
   \   0000001C   0xD208             BCS.N    ??TRACE_GetHexa32_1
    281                      value = (value * 16) + (key - '0');
   \   0000001E   0xF1A0 0x0530      SUB      R5,R0,#+48
    282                  }
   \                     ??TRACE_GetHexa32_2:
   \   00000022   0x1E76             SUBS     R6,R6,#+1
   \   00000024   0xD1F0             BNE.N    ??TRACE_GetHexa32_0
    283                  else if(key >= 'A' &&  key <= 'F' ) {
    284                      value = (value * 16) + (key - 'A' + 10) ;
    285                  }
    286                  else if(key >= 'a' &&  key <= 'f' ) {
    287                      value = (value * 16) + (key - 'a' + 10) ;
    288                  }        
    289                  else {
    290                      printf("\n\rIt is not a hexa character!\n\r");       
    291                      return 0; 
    292                  }
    293              }
    294          
    295              printf("\n\r");    
   \   00000026   0x.... 0x....      BL       ?Subroutine0
    296              *pValue = value;     
   \                     ??CrossCallReturnLabel_0:
   \   0000002A   0x6025             STR      R5,[R4, #+0]
    297              return 1;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??TRACE_GetHexa32_1:
   \   00000030   0xF1A7 0x0141      SUB      R1,R7,#+65
   \   00000034   0x2906             CMP      R1,#+6
   \   00000036   0xBF38             IT       CC 
   \   00000038   0xF1A0 0x0537      SUBCC    R5,R0,#+55
   \   0000003C   0xD3F1             BCC.N    ??TRACE_GetHexa32_2
   \   0000003E   0xF1A7 0x0161      SUB      R1,R7,#+97
   \   00000042   0x2906             CMP      R1,#+6
   \   00000044   0xBF38             IT       CC 
   \   00000046   0xF1A0 0x0557      SUBCC    R5,R0,#+87
   \   0000004A   0xD3EA             BCC.N    ??TRACE_GetHexa32_2
   \   0000004C   0x....             LDR.N    R0,??DataTable8_11
   \   0000004E   0x.... 0x....      BL       printf
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}
    298          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x2E 0x00          DC8      ".",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x25 0x63          DC8      0x25, 0x63, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x0A 0x0D          DC8      0x0A, 0x0D, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x20 0x20          DC8      0x20, 0x20, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x20 0x00          DC8      " ",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     __iar_Stdout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     __iar_Stderr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     `?<Constant "%02X ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     `?<Constant "0x%08X: ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     `?<Constant "\\n\\rWrite a number and ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     `?<Constant "\\n\\rThe number have to ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     `?<Constant "\\n\\rIt is not a hexa ch...">`

   \                                 In section .rodata, align 2
   \   00000000   0x2E 0x00          DC8 "."

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x63          DC8 "%c"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%02X ">`:
   \   00000000   0x25 0x30          DC8 "%02X "
   \              0x32 0x58    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x0A 0x0D          DC8 "\012\015"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "0x%08X: ">`:
   \   00000000   0x30 0x78          DC8 "0x%08X: "
   \              0x25 0x30    
   \              0x38 0x58    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   0000000C   0x25 0x30          DC8 "%02X%02X%02X%02X "
   \              0x32 0x58    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x25 0x30    
   \              0x32 0x58    
   \              0x20 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0
   \   00000020   0x25 0x30          DC8 "%02X"
   \              0x32 0x58    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \   00000000   0x20 0x00          DC8 " "

   \                                 In section .rodata, align 4
   \   00000000   0x20 0x20          DC8 "  "
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rWrite a number and ...">`:
   \   00000000   0x0A 0x0D          DC8 "\012\015Write a number and press ENTER or SPACE!\012\015"
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x65 0x20    
   \              0x61 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x61    
   \              0x6E 0x64    
   \              0x20 0x70    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x20 0x45    
   \              0x4E 0x54    
   \              0x45 0x52    
   \              0x20 0x6F    
   \              0x72 0x20    
   \              0x53 0x50    
   \              0x41 0x43    
   \              0x45 0x21    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000030   0x0A 0x0D          DC8 "\012\015'%c' not a number!\012\015"
   \              0x27 0x25    
   \              0x63 0x27    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x61    
   \              0x20 0x6E    
   \              0x75 0x6D    
   \              0x62 0x65    
   \              0x72 0x21    
   \              0x0A 0x0D    
   \              0x00         
   \   00000047   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rThe number have to ...">`:
   \   00000000   0x0A 0x0D          DC8 "\012\015The number have to be between %d and %d\012\015"
   \              0x54 0x68    
   \              0x65 0x20    
   \              0x6E 0x75    
   \              0x6D 0x62    
   \              0x65 0x72    
   \              0x20 0x68    
   \              0x61 0x76    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x62    
   \              0x65 0x20    
   \              0x62 0x65    
   \              0x74 0x77    
   \              0x65 0x65    
   \              0x6E 0x20    
   \              0x25 0x64    
   \              0x20 0x61    
   \              0x6E 0x64    
   \              0x20 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\n\\rIt is not a hexa ch...">`:
   \   00000000   0x0A 0x0D          DC8 "\012\015It is not a hexa character!\012\015"
   \              0x49 0x74    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x61 0x20    
   \              0x68 0x65    
   \              0x78 0x61    
   \              0x20 0x63    
   \              0x68 0x61    
   \              0x72 0x61    
   \              0x63 0x74    
   \              0x65 0x72    
   \              0x21 0x0A    
   \              0x0D 0x00    
    299          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  PrintChar
              0 -> printf
       24  TRACE_DumpFrame
              0 -> printf
             24 -> printf
       40  TRACE_DumpMemory
             40 -> PrintChar
              0 -> printf
             40 -> printf
       24  TRACE_GetHexa32
             24 -> DBGU_GetChar
             24 -> DBGU_PutChar
             24 -> printf
       24  TRACE_GetInteger
             24 -> DBGU_GetChar
             24 -> DBGU_PutChar
             24 -> printf
       24  TRACE_GetIntegerMinMax
             24 -> TRACE_GetInteger
             24 -> printf
        8  fputc
              8 -> DBGU_PutChar
       16  fputs
             16 -> fputc
        0  putchar
              0 -> fputc


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "  ">
       2  ?<Constant " ">
       8  ?<Constant "%02X ">
       4  ?<Constant "%c">
       2  ?<Constant ".">
      40  ?<Constant "0x%08X: ">
       4  ?<Constant "\n\r">
      32  ?<Constant "\n\rIt is not a hexa ch...">
      44  ?<Constant "\n\rThe number have to ...">
      72  ?<Constant "\n\rWrite a number and ...">
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       6  ?Subroutine0
      28  PrintChar
      36  TRACE_DumpFrame
     202  TRACE_DumpMemory
      86  TRACE_GetHexa32
      82  TRACE_GetInteger
      58  TRACE_GetIntegerMinMax
      32  fputc
      42  fputs
       4  putchar

 
 212 bytes in section .rodata
 624 bytes in section .text
 
 624 bytes of CODE  memory
 212 bytes of CONST memory

Errors: none
Warnings: none
