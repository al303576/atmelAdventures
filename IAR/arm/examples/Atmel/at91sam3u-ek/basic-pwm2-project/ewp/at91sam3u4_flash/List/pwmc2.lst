###############################################################################
#                                                                             #
#                                                       28/Feb/2012  20:28:09 #
# IAR ANSI C/C++ Compiler V6.30.6.33336/W32 KICKSTART for ARM                 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91lib\peripherals\pwmc\pwmc2.c                #
#    Command line =  C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91lib\peripherals\pwmc\pwmc2.c -D at91sam3u4  #
#                    -D flash -D TRACE_LEVEL=4 -lC                            #
#                    C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\at91sam3u4_ #
#                    flash\List\ --remarks --diag_suppress Pe826,Pe1375 -o    #
#                    C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\at91sam3u4_ #
#                    flash\Obj\ --debug --endian=little --cpu=Cortex-M3 -e    #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0                           #
#                    Kickstart_2\arm\INC\c\DLib_Config_Full.h" -I             #
#                    C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\..\..\..\at #
#                    91lib/peripherals\ -I C:\Users\Martin\Documents\AtmelAdv #
#                    entures\IAR\arm\examples\Atmel\at91sam3u-ek\basic-pwm2-p #
#                    roject\ewp\..\..\..\at91lib/components\ -I               #
#                    C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\..\..\..\at #
#                    91lib\ -I C:\Users\Martin\Documents\AtmelAdventures\IAR\ #
#                    arm\examples\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\. #
#                    .\..\..\external_libs\ -I C:\Users\Martin\Documents\Atme #
#                    lAdventures\IAR\arm\examples\Atmel\at91sam3u-ek\basic-pw #
#                    m2-project\ewp\..\..\..\at91lib/boards/at91sam3u-ek\     #
#                    -Ohz --use_c++_inline                                    #
#    List file    =  C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\at91sam3u4_ #
#                    flash\List\pwmc2.lst                                     #
#    Object file  =  C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\exampl #
#                    es\Atmel\at91sam3u-ek\basic-pwm2-project\ewp\at91sam3u4_ #
#                    flash\Obj\pwmc2.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Martin\Documents\AtmelAdventures\IAR\arm\examples\Atmel\at91lib\peripherals\pwmc\pwmc2.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "pwmc2.h"
     35          #include <board.h>
     36          #include <utility/assert.h>
     37          #include <utility/trace.h>
     38          
     39          //------------------------------------------------------------------------------
     40          //         Local functions
     41          //------------------------------------------------------------------------------
     42          
     43          //------------------------------------------------------------------------------
     44          /// Finds a prescaler/divisor couple to generate the desired frequency from
     45          /// MCK.
     46          /// Returns the value to enter in PWMC_MR or 0 if the configuration cannot be
     47          /// met.
     48          /// \param frequency  Desired frequency in Hz.
     49          /// \param mck  Master clock frequency in Hz.
     50          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     51          static unsigned short FindClockConfiguration(
     52              unsigned int frequency,
     53              unsigned int mck)
     54          {
   \                     FindClockConfiguration:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
     55              unsigned int divisors[11] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024};
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable23
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x4631             MOV      R1,R6
   \   00000010   0x222C             MOVS     R2,#+44
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy4
     56              unsigned char divisor = 0;
   \   00000016   0x2000             MOVS     R0,#+0
     57              unsigned int prescaler;
     58          
     59              SANITY_CHECK(frequency < mck);
   \   00000018   0x42AC             CMP      R4,R5
   \   0000001A   0xD30B             BCC.N    ??FindClockConfiguration_0
   \   0000001C   0xF106 0x002C      ADD      R0,R6,#+44
   \   00000020   0x.... 0x....      BL       printf
   \   00000024   0x223B             MOVS     R2,#+59
   \   00000026   0xF106 0x015C      ADD      R1,R6,#+92
   \   0000002A   0xF106 0x003C      ADD      R0,R6,#+60
   \   0000002E   0x.... 0x....      BL       printf
   \                     ??FindClockConfiguration_1:
   \   00000032   0xE7FE             B.N      ??FindClockConfiguration_1
     60          
     61              // Find prescaler and divisor values
     62              prescaler = (mck / divisors[divisor]) / frequency;
   \                     ??FindClockConfiguration_0:
   \   00000034   0x9900             LDR      R1,[SP, #+0]
   \   00000036   0xE004             B.N      ??FindClockConfiguration_2
     63              while ((prescaler > 255) && (divisor < 11)) {
     64          
     65                  divisor++;
   \                     ??FindClockConfiguration_3:
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0xB2C0             UXTB     R0,R0
     66                  prescaler = (mck / divisors[divisor]) / frequency;
   \   0000003C   0xA900             ADD      R1,SP,#+0
   \   0000003E   0xF851 0x1020      LDR      R1,[R1, R0, LSL #+2]
   \                     ??FindClockConfiguration_2:
   \   00000042   0xFBB5 0xF1F1      UDIV     R1,R5,R1
   \   00000046   0xFBB1 0xF1F4      UDIV     R1,R1,R4
     67              }
   \   0000004A   0x29FF             CMP      R1,#+255
   \   0000004C   0xD901             BLS.N    ??FindClockConfiguration_4
   \   0000004E   0x280B             CMP      R0,#+11
   \   00000050   0xDBF2             BLT.N    ??FindClockConfiguration_3
     68          
     69              // Return result
     70              if (divisor < 11) {
   \                     ??FindClockConfiguration_4:
   \   00000052   0x280B             CMP      R0,#+11
   \   00000054   0xBFBA             ITTE     LT 
   \   00000056   0xEA41 0x2000      ORRLT    R0,R1,R0, LSL #+8
   \   0000005A   0xB280             UXTHLT   R0,R0
   \   0000005C   0x2000             MOVGE    R0,#+0
     71          
     72                  TRACE_DEBUG("Found divisor=%u and prescaler=%u for freq=%uHz\n\r",
     73                            divisors[divisor], prescaler, frequency);
     74                  return prescaler | (divisor << 8);
     75              }
     76              else {
     77          
     78                  return 0;
   \   0000005E   0xB00C             ADD      SP,SP,#+48
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
     79              }
     80          }
     81          
     82          //------------------------------------------------------------------------------
     83          //         Global functions
     84          //------------------------------------------------------------------------------
     85          
     86          //------------------------------------------------------------------------------
     87          /// Configures PWM a channel with the given parameters, basic configure function.
     88          /// The PWM controller must have been clocked in the PMC prior to calling this
     89          /// function.
     90          /// Beware: this function disables the channel. It waits until disable is effective.
     91          /// \param channel  Channel number.
     92          /// \param prescaler  Channel prescaler.
     93          /// \param alignment  Channel alignment.
     94          /// \param polarity  Channel polarity.
     95          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     96          void PWMC_ConfigureChannel(
     97              unsigned char channel,
     98              unsigned int prescaler,
     99              unsigned int alignment,
    100              unsigned int polarity)
    101          {
   \                     PWMC_ConfigureChannel:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    102              SANITY_CHECK(prescaler < AT91C_PWMC_CPRE_MCKB);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable23
   \   00000006   0x290C             CMP      R1,#+12
   \   00000008   0xD305             BCC.N    ??PWMC_ConfigureChannel_0
   \   0000000A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_25:
   \   0000000E   0x2266             MOVS     R2,#+102
   \   00000010   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_12:
   \   00000014   0xE7FE             B.N      ??CrossCallReturnLabel_12
    103              SANITY_CHECK((alignment & ~AT91C_PWMC_CALG) == 0);
                                               ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??PWMC_ConfigureChannel_0:
   \   00000016   0xF432 0x7580      BICS     R5,R2,#0x100
   \   0000001A   0xD005             BEQ.N    ??PWMC_ConfigureChannel_1
   \   0000001C   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_24:
   \   00000020   0x2267             MOVS     R2,#+103
   \   00000022   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_11:
   \   00000026   0xE7FE             B.N      ??CrossCallReturnLabel_11
    104              SANITY_CHECK((polarity & ~AT91C_PWMC_CPOL) == 0);
                                              ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??PWMC_ConfigureChannel_1:
   \   00000028   0xF433 0x7500      BICS     R5,R3,#0x200
   \   0000002C   0xD005             BEQ.N    ??PWMC_ConfigureChannel_2
   \   0000002E   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_23:
   \   00000032   0x2268             MOVS     R2,#+104
   \   00000034   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_10:
   \   00000038   0xE7FE             B.N      ??CrossCallReturnLabel_10
   \                     ??PWMC_ConfigureChannel_2:
   \   0000003A   0x2401             MOVS     R4,#+1
   \   0000003C   0x4084             LSLS     R4,R4,R0
   \   0000003E   0x.... 0x....      LDR.W    R5,??DataTable23_1  ;; 0x4008c008
   \   00000042   0x686E             LDR      R6,[R5, #+4]
   \   00000044   0x4226             TST      R6,R4
   \   00000046   0xD003             BEQ.N    ??PWMC_ConfigureChannel_3
    105          
    106              // Disable channel (effective at the end of the current period)
    107              if ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) != 0) {
    108                  AT91C_BASE_PWMC->PWMC_DIS = 1 << channel;
   \   00000048   0x602C             STR      R4,[R5, #+0]
    109                  while ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) != 0);
   \                     ??PWMC_ConfigureChannel_4:
   \   0000004A   0x686E             LDR      R6,[R5, #+4]
   \   0000004C   0x4226             TST      R6,R4
   \   0000004E   0xD1FC             BNE.N    ??PWMC_ConfigureChannel_4
    110              }
    111          
    112              // Configure channel
    113              AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CMR = prescaler | alignment | polarity;
   \                     ??PWMC_ConfigureChannel_3:
   \   00000050   0x4311             ORRS     R1,R2,R1
   \   00000052   0x4319             ORRS     R1,R3,R1
   \   00000054   0x0140             LSLS     R0,R0,#+5
   \   00000056   0x.... 0x....      LDR.W    R2,??DataTable23_2  ;; 0x4008c200
   \   0000005A   0x5081             STR      R1,[R0, R2]
    114          }
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0xF104 0x002C      ADD      R0,R4,#+44
   \   00000004   0x.... 0x....      B.W      printf

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xF104 0x015C      ADD      R1,R4,#+92
   \   00000004   0xF104 0x003C      ADD      R0,R4,#+60
   \   00000008   0x.... 0x....      B.W      printf
    115          
    116          //------------------------------------------------------------------------------
    117          /// Configures PWM a channel with the given parameters, extend configure function.
    118          /// The PWM controller must have been clocked in the PMC prior to calling this
    119          /// function.
    120          /// Beware: this function disables the channel. It waits until disable is effective.
    121          /// \param channel            Channel number.
    122          /// \param prescaler          Channel prescaler.
    123          /// \param alignment          Channel alignment.
    124          /// \param polarity           Channel polarity.
    125          /// \param countEventSelect   Channel counter event selection.
    126          /// \param DTEnable           Channel dead time generator enable.
    127          /// \param DTHInverte         Channel Dead-Time PWMHx output Inverted.
    128          /// \param DTLInverte         Channel Dead-Time PWMHx output Inverted.
    129          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    130          void PWMC_ConfigureChannelExt(
    131              unsigned char channel,
    132              unsigned int prescaler,
    133              unsigned int alignment,
    134              unsigned int polarity,
    135              unsigned int countEventSelect,
    136              unsigned int DTEnable,
    137              unsigned int DTHInverte,
    138              unsigned int DTLInverte)
    139          {
   \                     PWMC_ConfigureChannelExt:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x9D06             LDR      R5,[SP, #+24]
   \   00000006   0x9E07             LDR      R6,[SP, #+28]
   \   00000008   0x9F08             LDR      R7,[SP, #+32]
   \   0000000A   0xF8DD 0xC024      LDR      R12,[SP, #+36]
    140              SANITY_CHECK(prescaler < AT91C_PWMC_CPRE_MCKB);
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable23
   \   00000012   0x290C             CMP      R1,#+12
   \   00000014   0xD305             BCC.N    ??PWMC_ConfigureChannelExt_0
   \   00000016   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_22:
   \   0000001A   0x228C             MOVS     R2,#+140
   \   0000001C   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_9:
   \   00000020   0xE7FE             B.N      ??CrossCallReturnLabel_9
    141              SANITY_CHECK((alignment & ~AT91C_PWMC_CALG) == 0);
                                               ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??PWMC_ConfigureChannelExt_0:
   \   00000022   0xF432 0x7E80      BICS     LR,R2,#0x100
   \   00000026   0xD005             BEQ.N    ??PWMC_ConfigureChannelExt_1
   \   00000028   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_21:
   \   0000002C   0x228D             MOVS     R2,#+141
   \   0000002E   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_8:
   \   00000032   0xE7FE             B.N      ??CrossCallReturnLabel_8
    142              SANITY_CHECK((polarity & ~AT91C_PWMC_CPOL) == 0);
                                              ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??PWMC_ConfigureChannelExt_1:
   \   00000034   0xF433 0x7E00      BICS     LR,R3,#0x200
   \   00000038   0xD005             BEQ.N    ??PWMC_ConfigureChannelExt_2
   \   0000003A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_20:
   \   0000003E   0x228E             MOVS     R2,#+142
   \   00000040   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_7:
   \   00000044   0xE7FE             B.N      ??CrossCallReturnLabel_7
    143              SANITY_CHECK((countEventSelect & ~AT91C_PWMC_CES) == 0);
                                                      ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??PWMC_ConfigureChannelExt_2:
   \   00000046   0xF435 0x6E80      BICS     LR,R5,#0x400
   \   0000004A   0xD005             BEQ.N    ??PWMC_ConfigureChannelExt_3
   \   0000004C   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_19:
   \   00000050   0x228F             MOVS     R2,#+143
   \   00000052   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_6:
   \   00000056   0xE7FE             B.N      ??CrossCallReturnLabel_6
    144              SANITY_CHECK((DTEnable & ~AT91C_PWMC_DTE) == 0);
                                              ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??PWMC_ConfigureChannelExt_3:
   \   00000058   0xF436 0x3E80      BICS     LR,R6,#0x10000
   \   0000005C   0xD005             BEQ.N    ??PWMC_ConfigureChannelExt_4
   \   0000005E   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_18:
   \   00000062   0x2290             MOVS     R2,#+144
   \   00000064   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5:
   \   00000068   0xE7FE             B.N      ??CrossCallReturnLabel_5
    145              SANITY_CHECK((DTHInverte & ~AT91C_PWMC_DTHI) == 0);
                                                ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??PWMC_ConfigureChannelExt_4:
   \   0000006A   0xF437 0x3E00      BICS     LR,R7,#0x20000
   \   0000006E   0xD005             BEQ.N    ??PWMC_ConfigureChannelExt_5
   \   00000070   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_17:
   \   00000074   0x2291             MOVS     R2,#+145
   \   00000076   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4:
   \   0000007A   0xE7FE             B.N      ??CrossCallReturnLabel_4
    146              SANITY_CHECK((DTLInverte & ~AT91C_PWMC_DTLI) == 0);
                                                ^
Remark[Pe068]: integer conversion resulted in a change of sign
   \                     ??PWMC_ConfigureChannelExt_5:
   \   0000007C   0xF43C 0x2E80      BICS     LR,R12,#0x40000
   \   00000080   0xD005             BEQ.N    ??PWMC_ConfigureChannelExt_6
   \   00000082   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_16:
   \   00000086   0x2292             MOVS     R2,#+146
   \   00000088   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3:
   \   0000008C   0xE7FE             B.N      ??CrossCallReturnLabel_3
   \                     ??PWMC_ConfigureChannelExt_6:
   \   0000008E   0x2401             MOVS     R4,#+1
   \   00000090   0x4084             LSLS     R4,R4,R0
   \   00000092   0x.... 0x....      LDR.W    LR,??DataTable23_1  ;; 0x4008c008
   \   00000096   0xF8DE 0x8004      LDR      R8,[LR, #+4]
   \   0000009A   0xEA18 0x0F04      TST      R8,R4
   \   0000009E   0xD006             BEQ.N    ??PWMC_ConfigureChannelExt_7
    147          
    148              // Disable channel (effective at the end of the current period)
    149              if ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) != 0) {
    150                  AT91C_BASE_PWMC->PWMC_DIS = 1 << channel;
   \   000000A0   0xF8CE 0x4000      STR      R4,[LR, #+0]
    151                  while ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) != 0);
   \                     ??PWMC_ConfigureChannelExt_8:
   \   000000A4   0xF8DE 0x8004      LDR      R8,[LR, #+4]
   \   000000A8   0xEA18 0x0F04      TST      R8,R4
   \   000000AC   0xD1FA             BNE.N    ??PWMC_ConfigureChannelExt_8
    152              }
    153          
    154              // Configure channel
    155              AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CMR = prescaler | alignment | polarity |
    156                  countEventSelect | DTEnable | DTHInverte | DTLInverte;
   \                     ??PWMC_ConfigureChannelExt_7:
   \   000000AE   0x4311             ORRS     R1,R2,R1
   \   000000B0   0x4319             ORRS     R1,R3,R1
   \   000000B2   0x4329             ORRS     R1,R5,R1
   \   000000B4   0x4331             ORRS     R1,R6,R1
   \   000000B6   0x4339             ORRS     R1,R7,R1
   \   000000B8   0xEA4C 0x0101      ORR      R1,R12,R1
   \   000000BC   0x0140             LSLS     R0,R0,#+5
   \   000000BE   0x....             LDR.N    R2,??DataTable23_2  ;; 0x4008c200
   \   000000C0   0x5081             STR      R1,[R0, R2]
    157          }
   \   000000C2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    158          
    159          //------------------------------------------------------------------------------
    160          /// Configures PWM clocks A & B to run at the given frequencies. This function
    161          /// finds the best MCK divisor and prescaler values automatically.
    162          /// \param clka  Desired clock A frequency (0 if not used).
    163          /// \param clkb  Desired clock B frequency (0 if not used).
    164          /// \param mck  Master clock frequency.
    165          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    166          void PWMC_ConfigureClocks(unsigned int clka, unsigned int clkb, unsigned int mck)
    167          {
   \                     PWMC_ConfigureClocks:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    168              unsigned int mode = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    169              unsigned int result;
    170          
    171              // Clock A
    172              if (clka != 0) {
   \   0000000C   0x.... 0x....      LDR.W    R8,??DataTable23
   \   00000010   0xF208 0x09C0      ADDW     R9,R8,#+192
   \   00000014   0xB174             CBZ.N    R4,??PWMC_ConfigureClocks_0
    173          
    174                  result = FindClockConfiguration(clka, mck);
   \   00000016   0x4631             MOV      R1,R6
   \   00000018   0x.... 0x....      BL       FindClockConfiguration
    175                  ASSERT(result != 0, "-F- Could not generate the desired PWM frequency (%uHz)\n\r", clka);
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0xD108             BNE.N    ??PWMC_ConfigureClocks_1
   \   00000020   0xF108 0x002C      ADD      R0,R8,#+44
   \   00000024   0x.... 0x....      BL       printf
   \   00000028   0x4621             MOV      R1,R4
   \   0000002A   0x4648             MOV      R0,R9
   \   0000002C   0x.... 0x....      BL       printf
   \                     ??PWMC_ConfigureClocks_2:
   \   00000030   0xE7FE             B.N      ??PWMC_ConfigureClocks_2
    176                  mode |= result;
   \                     ??PWMC_ConfigureClocks_1:
   \   00000032   0x4607             MOV      R7,R0
    177              }
    178          
    179              // Clock B
    180              if (clkb != 0) {
   \                     ??PWMC_ConfigureClocks_0:
   \   00000034   0xB185             CBZ.N    R5,??PWMC_ConfigureClocks_3
    181          
    182                  result = FindClockConfiguration(clkb, mck);
   \   00000036   0x4631             MOV      R1,R6
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       FindClockConfiguration
    183                  ASSERT(result != 0, "-F- Could not generate the desired PWM frequency (%uHz)\n\r", clkb);
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0xD108             BNE.N    ??PWMC_ConfigureClocks_4
   \   00000042   0xF108 0x002C      ADD      R0,R8,#+44
   \   00000046   0x.... 0x....      BL       printf
   \   0000004A   0x4629             MOV      R1,R5
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0x.... 0x....      BL       printf
   \                     ??PWMC_ConfigureClocks_5:
   \   00000052   0xE7FE             B.N      ??PWMC_ConfigureClocks_5
    184                  mode |= (result << 16);
   \                     ??PWMC_ConfigureClocks_4:
   \   00000054   0xEA47 0x4700      ORR      R7,R7,R0, LSL #+16
    185              }
    186          
    187              // Configure clocks
    188              TRACE_DEBUG("Setting PWMC_MR = 0x%08X\n\r", mode);
    189              AT91C_BASE_PWMC->PWMC_MR = mode;
   \                     ??PWMC_ConfigureClocks_3:
   \   00000058   0x....             LDR.N    R0,??DataTable23_3  ;; 0x4008c000
   \   0000005A   0x6007             STR      R7,[R0, #+0]
    190          }
   \   0000005C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    191          
    192          //------------------------------------------------------------------------------
    193          /// Sets the period value used by a PWM channel. This function writes directly
    194          /// to the CPRD register if the channel is disabled; otherwise, it uses the
    195          /// update register CUPD.
    196          /// \param channel  Channel number.
    197          /// \param period  Period value.
    198          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    199          void PWMC_SetPeriod(unsigned char channel, unsigned short period)
    200          {
   \                     PWMC_SetPeriod:
   \   00000000   0xB510             PUSH     {R4,LR}
    201              // If channel is disabled, write to CPRD
    202              if ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) == 0) {
   \   00000002   0x....             LDR.N    R2,??DataTable23_2  ;; 0x4008c200
   \   00000004   0xEB02 0x1240      ADD      R2,R2,R0, LSL #+5
   \   00000008   0x....             LDR.N    R3,??DataTable23_4  ;; 0x4008c00c
   \   0000000A   0x681B             LDR      R3,[R3, #+0]
   \   0000000C   0x2401             MOVS     R4,#+1
   \   0000000E   0xFA04 0xF000      LSL      R0,R4,R0
   \   00000012   0x4203             TST      R3,R0
   \   00000014   0xD101             BNE.N    ??PWMC_SetPeriod_0
    203          
    204                  AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CPRDR = period;
   \   00000016   0x60D1             STR      R1,[R2, #+12]
   \   00000018   0xBD10             POP      {R4,PC}
    205              }
    206              // Otherwise use update register
    207              else {
    208          
    209                  AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CPRDUPDR = period;
   \                     ??PWMC_SetPeriod_0:
   \   0000001A   0x6111             STR      R1,[R2, #+16]
    210              }
    211          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    212          
    213          //------------------------------------------------------------------------------
    214          /// Sets the duty cycle used by a PWM channel. This function writes directly to
    215          /// the CDTY register if the channel is disabled; otherwise it uses the
    216          /// update register CUPD.
    217          /// Note that the duty cycle must always be inferior or equal to the channel
    218          /// period.
    219          /// \param channel  Channel number.
    220          /// \param duty  Duty cycle value.
    221          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    222          void PWMC_SetDutyCycle(unsigned char channel, unsigned short duty)
    223          {
   \                     PWMC_SetDutyCycle:
   \   00000000   0xB510             PUSH     {R4,LR}
    224              SANITY_CHECK(duty <= AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CPRDR);
   \   00000002   0x....             LDR.N    R2,??DataTable23_2  ;; 0x4008c200
   \   00000004   0xEB02 0x1240      ADD      R2,R2,R0, LSL #+5
   \   00000008   0x68D3             LDR      R3,[R2, #+12]
   \   0000000A   0x428B             CMP      R3,R1
   \   0000000C   0xD206             BCS.N    ??PWMC_SetDutyCycle_0
   \   0000000E   0x....             LDR.N    R4,??DataTable23
   \   00000010   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_15:
   \   00000014   0x22E0             MOVS     R2,#+224
   \   00000016   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   0000001A   0xE7FE             B.N      ??CrossCallReturnLabel_2
    225          
    226              // SAM7S errata
    227          #if defined(at91sam7s16) || defined(at91sam7s161) || defined(at91sam7s32) \
    228              || defined(at91sam7s321) || defined(at91sam7s64) || defined(at91sam7s128) \
    229              || defined(at91sam7s256) || defined(at91sam7s512)
    230              ASSERT(duty > 0, "-F- Duty cycle value 0 is not permitted on SAM7S chips.\n\r");
    231              ASSERT((duty > 1) || (AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CMR & AT91C_PWMC_CALG),
    232                     "-F- Duty cycle value 1 is not permitted in left-aligned mode on SAM7S chips.\n\r");
    233          #endif
    234          
    235              // If channel is disabled, write to CDTY
    236              if ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) == 0) {
   \                     ??PWMC_SetDutyCycle_0:
   \   0000001C   0x....             LDR.N    R3,??DataTable23_4  ;; 0x4008c00c
   \   0000001E   0x681B             LDR      R3,[R3, #+0]
   \   00000020   0x2401             MOVS     R4,#+1
   \   00000022   0xFA04 0xF000      LSL      R0,R4,R0
   \   00000026   0x4203             TST      R3,R0
   \   00000028   0xD101             BNE.N    ??PWMC_SetDutyCycle_1
    237          
    238                  AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CDTYR = duty;
   \   0000002A   0x6051             STR      R1,[R2, #+4]
   \   0000002C   0xBD10             POP      {R4,PC}
    239              }
    240              // Otherwise use update register
    241              else {
    242          
    243                  AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CDTYUPDR = duty;
   \                     ??PWMC_SetDutyCycle_1:
   \   0000002E   0x6091             STR      R1,[R2, #+8]
    244              }
    245          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    246          
    247          //------------------------------------------------------------------------------
    248          /// Sets the dead time used by a PWM channel. This function writes directly to
    249          /// the DTR register if the channel is disabled; otherwise it uses the
    250          /// update register DTUPDR.
    251          /// Note that the dead time must always be inferior or equal to the channel
    252          /// period.
    253          /// \param channel  Channel number.
    254          /// \param timeH    Dead time value for PWMHx output.
    255          /// \param timeL    Dead time value for PWMLx output.
    256          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    257          void PWMC_SetDeadTime(unsigned char channel, unsigned short timeH, unsigned short timeL)
    258          {
   \                     PWMC_SetDeadTime:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    259              SANITY_CHECK(timeH <= AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CPRDR);
   \   00000002   0x....             LDR.N    R3,??DataTable23_2  ;; 0x4008c200
   \   00000004   0xEB03 0x1340      ADD      R3,R3,R0, LSL #+5
   \   00000008   0x....             LDR.N    R4,??DataTable23
   \   0000000A   0x68DD             LDR      R5,[R3, #+12]
   \   0000000C   0x428D             CMP      R5,R1
   \   0000000E   0xD206             BCS.N    ??PWMC_SetDeadTime_0
   \   00000010   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_14:
   \   00000014   0xF240 0x1203      MOVW     R2,#+259
   \   00000018   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   0000001C   0xE7FE             B.N      ??CrossCallReturnLabel_1
    260              SANITY_CHECK(timeL <= AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_CPRDR);
   \                     ??PWMC_SetDeadTime_0:
   \   0000001E   0x68DD             LDR      R5,[R3, #+12]
   \   00000020   0x4295             CMP      R5,R2
   \   00000022   0xD206             BCS.N    ??PWMC_SetDeadTime_1
   \   00000024   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_13:
   \   00000028   0xF44F 0x7282      MOV      R2,#+260
   \   0000002C   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0:
   \   00000030   0xE7FE             B.N      ??CrossCallReturnLabel_0
    261          
    262              // If channel is disabled, write to DTR
    263              if ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) == 0) {
   \                     ??PWMC_SetDeadTime_1:
   \   00000032   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000036   0x....             LDR.N    R2,??DataTable23_4  ;; 0x4008c00c
   \   00000038   0x6812             LDR      R2,[R2, #+0]
   \   0000003A   0x2401             MOVS     R4,#+1
   \   0000003C   0xFA04 0xF000      LSL      R0,R4,R0
   \   00000040   0x4202             TST      R2,R0
   \   00000042   0xD101             BNE.N    ??PWMC_SetDeadTime_2
    264          
    265                  AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_DTR = timeH | (timeL << 16);
   \   00000044   0x6199             STR      R1,[R3, #+24]
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}
    266              }
    267              // Otherwise use update register
    268              else {
    269                  AT91C_BASE_PWMC->PWMC_CH[channel].PWMC_DTUPDR = timeH | (timeL << 16);
   \                     ??PWMC_SetDeadTime_2:
   \   00000048   0x61D9             STR      R1,[R3, #+28]
    270              }
    271          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    272          
    273          //------------------------------------------------------------------------------
    274          /// Configures Syncronous channel with the given parameters.
    275          /// Beware: At this time, the channels should be disabled.
    276          /// \param channels                 Bitwise OR of Syncronous channels.
    277          /// \param updateMode               Syncronous channel update mode.
    278          /// \param requestMode              PDC transfer request mode.
    279          /// \param requestComparisonSelect  PDC transfer request comparison selection.
    280          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    281          void PWMC_ConfigureSyncChannel(
    282              unsigned int channels,
    283              unsigned int updateMode,
    284              unsigned int requestMode,
    285              unsigned int requestComparisonSelect)
    286          {
    287              AT91C_BASE_PWMC->PWMC_SYNC = channels | updateMode | requestMode
    288                  | requestComparisonSelect;
   \                     PWMC_ConfigureSyncChannel:
   \   00000000   0x4308             ORRS     R0,R1,R0
   \   00000002   0x4310             ORRS     R0,R2,R0
   \   00000004   0x4318             ORRS     R0,R3,R0
   \   00000006   0x....             LDR.N    R1,??DataTable23_5  ;; 0x4008c020
   \   00000008   0x6008             STR      R0,[R1, #+0]
    289          }
   \   0000000A   0x4770             BX       LR               ;; return
    290          
    291          //------------------------------------------------------------------------------
    292          /// Sets the update period of the synchronous channels.
    293          /// This function writes directly to
    294          /// the SCUP register if the channel #0 is disabled; otherwise it uses the
    295          /// update register SCUPUPD.
    296          /// \param period   update period.
    297          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    298          void PWMC_SetSyncChannelUpdatePeriod(unsigned char period)
    299          {
    300              // If channel is disabled, write to SCUP
    301              if ((AT91C_BASE_PWMC->PWMC_SR & (1 << 0)) == 0) {
   \                     PWMC_SetSyncChannelUpdatePeriod:
   \   00000000   0x....             LDR.N    R1,??DataTable23_4  ;; 0x4008c00c
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x07D2             LSLS     R2,R2,#+31
   \   00000006   0xD401             BMI.N    ??PWMC_SetSyncChannelUpdatePeriod_0
    302          
    303                  AT91C_BASE_PWMC->PWMC_SCUP = period;
   \   00000008   0x6208             STR      R0,[R1, #+32]
   \   0000000A   0x4770             BX       LR
    304              }
    305              // Otherwise use update register
    306              else {
    307          
    308                  AT91C_BASE_PWMC->PWMC_SCUPUPD = period;
   \                     ??PWMC_SetSyncChannelUpdatePeriod_0:
   \   0000000C   0x6248             STR      R0,[R1, #+36]
    309              }
    310          }
   \   0000000E   0x4770             BX       LR               ;; return
    311          
    312          //------------------------------------------------------------------------------
    313          /// Sets synchronous channels update unlock.
    314          /// Note: If the UPDM field is set to 0, writing the UPDULOCK bit to 1
    315          /// triggers the update of the period value, the duty-cycle and
    316          /// the dead-time values of synchronous channels at the beginning
    317          /// of the next PWM period. If the field UPDM is set to 1 or 2,
    318          /// writing the UPDULOCK bit to 1 triggers only the update of
    319          /// the period value and of the dead-time values of synchronous channels.
    320          /// This bit is automatically reset when the update is done.
    321          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    322          void PWMC_SetSyncChannelUpdateUnlock(void)
    323          {
    324              AT91C_BASE_PWMC->PWMC_UPCR = AT91C_PWMC_UPDULOCK;
   \                     PWMC_SetSyncChannelUpdateUnlock:
   \   00000000   0x....             LDR.N    R0,??DataTable23_6  ;; 0x4008c028
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x6001             STR      R1,[R0, #+0]
    325          }
   \   00000006   0x4770             BX       LR               ;; return
    326          
    327          //------------------------------------------------------------------------------
    328          /// Enables the given PWM channel. This does NOT enable the corresponding pin;
    329          /// this must be done in the user code.
    330          /// \param channel  Channel number.
    331          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    332          void PWMC_EnableChannel(unsigned char channel)
    333          {
    334              AT91C_BASE_PWMC->PWMC_ENA = 1 << channel;
   \                     PWMC_EnableChannel:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000006   0x....             LDR.N    R1,??DataTable23_7  ;; 0x4008c004
   \   00000008   0x6008             STR      R0,[R1, #+0]
    335          }
   \   0000000A   0x4770             BX       LR               ;; return
    336          
    337          //------------------------------------------------------------------------------
    338          /// Disables the given PWM channel.
    339          /// Beware, channel will be effectively disabled at the end of the current period.
    340          /// Application can check channel is disabled using the following wait loop:
    341          /// while ((AT91C_BASE_PWMC->PWMC_SR & (1 << channel)) != 0);
    342          /// \param channel  Channel number.
    343          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    344          void PWMC_DisableChannel(unsigned char channel)
    345          {
    346              AT91C_BASE_PWMC->PWMC_DIS = 1 << channel;
   \                     PWMC_DisableChannel:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000006   0x....             LDR.N    R1,??DataTable23_1  ;; 0x4008c008
   \   00000008   0x6008             STR      R0,[R1, #+0]
    347          }
   \   0000000A   0x4770             BX       LR               ;; return
    348          
    349          //------------------------------------------------------------------------------
    350          /// Enables the period interrupt for the given PWM channel.
    351          /// \param channel  Channel number.
    352          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    353          void PWMC_EnableChannelIt(unsigned char channel)
    354          {
    355              AT91C_BASE_PWMC->PWMC_IER1 = 1 << channel;
   \                     PWMC_EnableChannelIt:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000006   0x....             LDR.N    R1,??DataTable23_8  ;; 0x4008c010
   \   00000008   0x6008             STR      R0,[R1, #+0]
    356          }
   \   0000000A   0x4770             BX       LR               ;; return
    357          
    358          //------------------------------------------------------------------------------
    359          /// Disables the period interrupt for the given PWM channel.
    360          /// \param channel  Channel number.
    361          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    362          void PWMC_DisableChannelIt(unsigned char channel)
    363          {
    364              AT91C_BASE_PWMC->PWMC_IDR1 = 1 << channel;
   \                     PWMC_DisableChannelIt:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000006   0x....             LDR.N    R1,??DataTable23_9  ;; 0x4008c014
   \   00000008   0x6008             STR      R0,[R1, #+0]
    365          }
   \   0000000A   0x4770             BX       LR               ;; return
    366          
    367          //-----------------------------------------------------------------------------
    368          /// Enables the selected interrupts sources on a PWMC peripheral.
    369          /// \param sources1  Bitwise OR of selected interrupt sources of PWMC_IER1.
    370          /// \param sources2  Bitwise OR of selected interrupt sources of PWMC_IER2.
    371          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    372          void PWMC_EnableIt(unsigned int sources1, unsigned int sources2)
    373          {
    374              AT91C_BASE_PWMC->PWMC_IER1 = sources1;
   \                     PWMC_EnableIt:
   \   00000000   0x....             LDR.N    R2,??DataTable23_8  ;; 0x4008c010
   \   00000002   0x....             B.N      ?Subroutine0
    375              AT91C_BASE_PWMC->PWMC_IER2 = sources2;
    376          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x6010             STR      R0,[R2, #+0]
   \   00000002   0x6251             STR      R1,[R2, #+36]
   \   00000004   0x4770             BX       LR               ;; return
    377          
    378          //-----------------------------------------------------------------------------
    379          /// Disables the selected interrupts sources on a PWMC peripheral.
    380          /// \param sources1  Bitwise OR of selected interrupt sources of PWMC_IDR1.
    381          /// \param sources2  Bitwise OR of selected interrupt sources of PWMC_IDR2.
    382          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    383          void PWMC_DisableIt(unsigned int sources1, unsigned int sources2)
    384          {
    385              AT91C_BASE_PWMC->PWMC_IDR1 = sources1;
   \                     PWMC_DisableIt:
   \   00000000   0x....             LDR.N    R2,??DataTable23_9  ;; 0x4008c014
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    386              AT91C_BASE_PWMC->PWMC_IDR2 = sources2;
    387          }
    388          
    389          //------------------------------------------------------------------------------
    390          /// Sends the contents of buffer through a PWMC peripheral, using the PDC to
    391          /// take care of the transfer.
    392          /// Note: Duty cycle of syncronous channels can update by PDC
    393          ///       when the field UPDM (Update Mode) in the PWM_SCM register is set to 2.
    394          /// \param pwmc    Pointer to an AT91S_PWMC instance.
    395          /// \param buffer  Data buffer to send.
    396          /// \param length  Length of the data buffer.
    397          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    398          unsigned char PWMC_WriteBuffer(AT91S_PWMC *pwmc,
    399              void *buffer,
    400              unsigned int length)
    401          {
   \                     PWMC_WriteBuffer:
   \   00000000   0xB510             PUSH     {R4,LR}
    402              // Check if first bank is free
    403              if (pwmc->PWMC_TCR == 0) {
   \   00000002   0xF200 0x1308      ADDW     R3,R0,#+264
   \   00000006   0x685C             LDR      R4,[R3, #+4]
   \   00000008   0xB934             CBNZ.N   R4,??PWMC_WriteBuffer_0
    404          
    405                  pwmc->PWMC_TPR = (unsigned int) buffer;
   \   0000000A   0xF8C0 0x1108      STR      R1,[R0, #+264]
    406                  pwmc->PWMC_TCR = length;
   \   0000000E   0x605A             STR      R2,[R3, #+4]
    407                  pwmc->PWMC_PTCR = AT91C_PDC_TXTEN;
   \   00000010   0xF44F 0x7080      MOV      R0,#+256
   \   00000014   0x6198             STR      R0,[R3, #+24]
    408                  return 1;
   \   00000016   0xE003             B.N      ??PWMC_WriteBuffer_1
    409              }
    410              // Check if second bank is free
    411              else if (pwmc->PWMC_TNCR == 0) {
   \                     ??PWMC_WriteBuffer_0:
   \   00000018   0x6958             LDR      R0,[R3, #+20]
   \   0000001A   0xB918             CBNZ.N   R0,??PWMC_WriteBuffer_2
    412          
    413                  pwmc->PWMC_TNPR = (unsigned int) buffer;
   \   0000001C   0x6119             STR      R1,[R3, #+16]
    414                  pwmc->PWMC_TNCR = length;
   \   0000001E   0x615A             STR      R2,[R3, #+20]
    415                  return 1;
   \                     ??PWMC_WriteBuffer_1:
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBD10             POP      {R4,PC}
    416              }
    417          
    418              // No free banks
    419              return 0;
   \                     ??PWMC_WriteBuffer_2:
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    420          }
    421          
    422          //-----------------------------------------------------------------------------
    423          /// Set PWM output override value
    424          /// \param value  Bitwise OR of output override value.
    425          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    426          void PWMC_SetOverrideValue(unsigned int value)
    427          {
    428              AT91C_BASE_PWMC->PWMC_OOV = value;
   \                     PWMC_SetOverrideValue:
   \   00000000   0x....             LDR.N    R1,??DataTable23_10  ;; 0x4008c044
   \   00000002   0x6008             STR      R0,[R1, #+0]
    429          }
   \   00000004   0x4770             BX       LR               ;; return
    430          
    431          //-----------------------------------------------------------------------------
    432          /// Enalbe override output.
    433          /// \param value  Bitwise OR of output selection.
    434          /// \param sync   0: enable the output asyncronously, 1: enable it syncronously
    435          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    436          void PWMC_EnableOverrideOutput(unsigned int value, unsigned int sync)
    437          {
    438              if (sync) {
   \                     PWMC_EnableOverrideOutput:
   \   00000000   0x....             LDR.N    R2,??DataTable23_11  ;; 0x4008c04c
   \   00000002   0xB109             CBZ.N    R1,??PWMC_EnableOverrideOutput_0
    439          
    440                  AT91C_BASE_PWMC->PWMC_OSSUPD = value;
   \   00000004   0x6090             STR      R0,[R2, #+8]
   \   00000006   0x4770             BX       LR
    441              } else {
    442          
    443                  AT91C_BASE_PWMC->PWMC_OSS = value;
   \                     ??PWMC_EnableOverrideOutput_0:
   \   00000008   0x6010             STR      R0,[R2, #+0]
    444              }
    445          }
   \   0000000A   0x4770             BX       LR               ;; return
    446          
    447          //-----------------------------------------------------------------------------
    448          /// Disalbe override output.
    449          /// \param value  Bitwise OR of output selection.
    450          /// \param sync   0: enable the output asyncronously, 1: enable it syncronously
    451          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    452          void PWMC_DisableOverrideOutput(unsigned int value, unsigned int sync)
    453          {
    454              if (sync) {
   \                     PWMC_DisableOverrideOutput:
   \   00000000   0x....             LDR.N    R2,??DataTable23_12  ;; 0x4008c050
   \   00000002   0xB109             CBZ.N    R1,??PWMC_DisableOverrideOutput_0
    455          
    456                  AT91C_BASE_PWMC->PWMC_OSCUPD = value;
   \   00000004   0x6090             STR      R0,[R2, #+8]
   \   00000006   0x4770             BX       LR
    457              } else {
    458          
    459                  AT91C_BASE_PWMC->PWMC_OSC = value;
   \                     ??PWMC_DisableOverrideOutput_0:
   \   00000008   0x6010             STR      R0,[R2, #+0]
    460              }
    461          }
   \   0000000A   0x4770             BX       LR               ;; return
    462          
    463          //-----------------------------------------------------------------------------
    464          /// Set PWM fault mode.
    465          /// \param mode  Bitwise OR of fault mode.
    466          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    467          void PWMC_SetFaultMode(unsigned int mode)
    468          {
    469              AT91C_BASE_PWMC->PWMC_FMR = mode;
   \                     PWMC_SetFaultMode:
   \   00000000   0x....             LDR.N    R1,??DataTable23_13  ;; 0x4008c05c
   \   00000002   0x6008             STR      R0,[R1, #+0]
    470          }
   \   00000004   0x4770             BX       LR               ;; return
    471          
    472          //-----------------------------------------------------------------------------
    473          /// PWM fault clear.
    474          /// \param fault  Bitwise OR of fault to clear.
    475          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    476          void PWMC_FaultClear(unsigned int fault)
    477          {
    478              AT91C_BASE_PWMC->PWMC_FCR = fault;
   \                     PWMC_FaultClear:
   \   00000000   0x....             LDR.N    R1,??DataTable23_14  ;; 0x4008c064
   \   00000002   0x6008             STR      R0,[R1, #+0]
    479          }
   \   00000004   0x4770             BX       LR               ;; return
    480          
    481          //-----------------------------------------------------------------------------
    482          /// Set PWM fault protection value.
    483          /// \param value  Bitwise OR of fault protection value.
    484          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    485          void PWMC_SetFaultProtectionValue(unsigned int value)
    486          {
    487              AT91C_BASE_PWMC->PWMC_FPV = value;
   \                     PWMC_SetFaultProtectionValue:
   \   00000000   0x....             LDR.N    R1,??DataTable23_15  ;; 0x4008c068
   \   00000002   0x6008             STR      R0,[R1, #+0]
    488          }
   \   00000004   0x4770             BX       LR               ;; return
    489          
    490          //-----------------------------------------------------------------------------
    491          /// Enable PWM fault protection.
    492          /// \param value  Bitwise OR of FPEx[y].
    493          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    494          void PWMC_EnableFaultProtection(unsigned int value)
    495          {
    496              AT91C_BASE_PWMC->PWMC_FPER1 = value;
   \                     PWMC_EnableFaultProtection:
   \   00000000   0x....             LDR.N    R1,??DataTable23_16  ;; 0x4008c06c
   \   00000002   0x6008             STR      R0,[R1, #+0]
    497          }
   \   00000004   0x4770             BX       LR               ;; return
    498          
    499          //-----------------------------------------------------------------------------
    500          /// Configure comparison unit.
    501          /// \param x     comparison x index
    502          /// \param value comparison x value.
    503          /// \param mode  comparison x mode
    504          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    505          void PWMC_ConfigureComparisonUnit(unsigned int x, unsigned int value, unsigned int mode)
    506          {
   \                     PWMC_ConfigureComparisonUnit:
   \   00000000   0xB510             PUSH     {R4,LR}
    507              // If channel is disabled, write to CMPxM & CMPxV
    508              if ((AT91C_BASE_PWMC->PWMC_SR & (1 << 0)) == 0) {
   \   00000002   0x....             LDR.N    R3,??DataTable23_17  ;; 0x4008c130
   \   00000004   0x....             LDR.N    R4,??DataTable23_4  ;; 0x4008c00c
   \   00000006   0x6824             LDR      R4,[R4, #+0]
   \   00000008   0x07E4             LSLS     R4,R4,#+31
   \   0000000A   0xD426             BMI.N    ??PWMC_ConfigureComparisonUnit_0
    509                  if (x == 0) {
   \   0000000C   0xB910             CBNZ.N   R0,??PWMC_ConfigureComparisonUnit_1
    510                      AT91C_BASE_PWMC->PWMC_CMP0M = mode;
   \   0000000E   0x609A             STR      R2,[R3, #+8]
    511                      AT91C_BASE_PWMC->PWMC_CMP0V = value;
   \   00000010   0x6019             STR      R1,[R3, #+0]
   \   00000012   0xBD10             POP      {R4,PC}
    512                  } else if (x == 1) {
   \                     ??PWMC_ConfigureComparisonUnit_1:
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_2
    513                      AT91C_BASE_PWMC->PWMC_CMP1M = mode;
   \   00000018   0x619A             STR      R2,[R3, #+24]
    514                      AT91C_BASE_PWMC->PWMC_CMP1V = value;
   \   0000001A   0x6119             STR      R1,[R3, #+16]
   \   0000001C   0xBD10             POP      {R4,PC}
    515                  } else if (x == 2) {
   \                     ??PWMC_ConfigureComparisonUnit_2:
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_3
    516                      AT91C_BASE_PWMC->PWMC_CMP2M = mode;
   \   00000022   0x629A             STR      R2,[R3, #+40]
    517                      AT91C_BASE_PWMC->PWMC_CMP2V = value;
   \   00000024   0x6219             STR      R1,[R3, #+32]
   \   00000026   0xBD10             POP      {R4,PC}
    518                  } else if (x == 3) {
   \                     ??PWMC_ConfigureComparisonUnit_3:
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_4
    519                      AT91C_BASE_PWMC->PWMC_CMP3M = mode;
   \   0000002C   0x639A             STR      R2,[R3, #+56]
    520                      AT91C_BASE_PWMC->PWMC_CMP3V = value;
   \   0000002E   0x6319             STR      R1,[R3, #+48]
   \   00000030   0xBD10             POP      {R4,PC}
    521                  } else if (x == 4) {
   \                     ??PWMC_ConfigureComparisonUnit_4:
   \   00000032   0x2804             CMP      R0,#+4
   \   00000034   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_5
    522                      AT91C_BASE_PWMC->PWMC_CMP4M = mode;
   \   00000036   0x649A             STR      R2,[R3, #+72]
    523                      AT91C_BASE_PWMC->PWMC_CMP4V = value;
   \   00000038   0x6419             STR      R1,[R3, #+64]
   \   0000003A   0xBD10             POP      {R4,PC}
    524                  } else if (x == 5) {
   \                     ??PWMC_ConfigureComparisonUnit_5:
   \   0000003C   0x2805             CMP      R0,#+5
   \   0000003E   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_6
    525                      AT91C_BASE_PWMC->PWMC_CMP5M = mode;
   \   00000040   0x659A             STR      R2,[R3, #+88]
    526                      AT91C_BASE_PWMC->PWMC_CMP5V = value;
   \   00000042   0x6519             STR      R1,[R3, #+80]
   \   00000044   0xBD10             POP      {R4,PC}
    527                  } else if (x == 6) {
   \                     ??PWMC_ConfigureComparisonUnit_6:
   \   00000046   0x2806             CMP      R0,#+6
   \   00000048   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_7
    528                      AT91C_BASE_PWMC->PWMC_CMP6M = mode;
   \   0000004A   0x669A             STR      R2,[R3, #+104]
    529                      AT91C_BASE_PWMC->PWMC_CMP6V = value;
   \   0000004C   0x6619             STR      R1,[R3, #+96]
   \   0000004E   0xBD10             POP      {R4,PC}
    530                  } else if (x == 7) {
   \                     ??PWMC_ConfigureComparisonUnit_7:
   \   00000050   0x2807             CMP      R0,#+7
   \   00000052   0xD128             BNE.N    ??PWMC_ConfigureComparisonUnit_8
    531                      AT91C_BASE_PWMC->PWMC_CMP7M = mode;
   \   00000054   0x679A             STR      R2,[R3, #+120]
    532                      AT91C_BASE_PWMC->PWMC_CMP7V = value;
   \   00000056   0x6719             STR      R1,[R3, #+112]
   \   00000058   0xBD10             POP      {R4,PC}
    533                  }
    534              } 
    535              // Otherwise use update register
    536              else {
    537                  if (x == 0) {
   \                     ??PWMC_ConfigureComparisonUnit_0:
   \   0000005A   0xB910             CBNZ.N   R0,??PWMC_ConfigureComparisonUnit_9
    538                      AT91C_BASE_PWMC->PWMC_CMP0MUPD = mode;
   \   0000005C   0x60DA             STR      R2,[R3, #+12]
    539                      AT91C_BASE_PWMC->PWMC_CMP0VUPD = value;
   \   0000005E   0x6059             STR      R1,[R3, #+4]
   \   00000060   0xBD10             POP      {R4,PC}
    540                  } else if (x == 1) {
   \                     ??PWMC_ConfigureComparisonUnit_9:
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_10
    541                      AT91C_BASE_PWMC->PWMC_CMP1MUPD = mode;
   \   00000066   0x61DA             STR      R2,[R3, #+28]
    542                      AT91C_BASE_PWMC->PWMC_CMP1VUPD = value;
   \   00000068   0x6159             STR      R1,[R3, #+20]
   \   0000006A   0xBD10             POP      {R4,PC}
    543                  } else if (x == 2) {
   \                     ??PWMC_ConfigureComparisonUnit_10:
   \   0000006C   0x2802             CMP      R0,#+2
   \   0000006E   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_11
    544                      AT91C_BASE_PWMC->PWMC_CMP2MUPD = mode;
   \   00000070   0x62DA             STR      R2,[R3, #+44]
    545                      AT91C_BASE_PWMC->PWMC_CMP2VUPD = value;
   \   00000072   0x6259             STR      R1,[R3, #+36]
   \   00000074   0xBD10             POP      {R4,PC}
    546                  } else if (x == 3) {
   \                     ??PWMC_ConfigureComparisonUnit_11:
   \   00000076   0x2803             CMP      R0,#+3
   \   00000078   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_12
    547                      AT91C_BASE_PWMC->PWMC_CMP3MUPD = mode;
   \   0000007A   0x63DA             STR      R2,[R3, #+60]
    548                      AT91C_BASE_PWMC->PWMC_CMP3VUPD = value;
   \   0000007C   0x6359             STR      R1,[R3, #+52]
   \   0000007E   0xBD10             POP      {R4,PC}
    549                  } else if (x == 4) {
   \                     ??PWMC_ConfigureComparisonUnit_12:
   \   00000080   0x2804             CMP      R0,#+4
   \   00000082   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_13
    550                      AT91C_BASE_PWMC->PWMC_CMP4MUPD = mode;
   \   00000084   0x64DA             STR      R2,[R3, #+76]
    551                      AT91C_BASE_PWMC->PWMC_CMP4VUPD = value;
   \   00000086   0x6459             STR      R1,[R3, #+68]
   \   00000088   0xBD10             POP      {R4,PC}
    552                  } else if (x == 5) {
   \                     ??PWMC_ConfigureComparisonUnit_13:
   \   0000008A   0x2805             CMP      R0,#+5
   \   0000008C   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_14
    553                      AT91C_BASE_PWMC->PWMC_CMP5MUPD = mode;
   \   0000008E   0x65DA             STR      R2,[R3, #+92]
    554                      AT91C_BASE_PWMC->PWMC_CMP5VUPD = value;
   \   00000090   0x6559             STR      R1,[R3, #+84]
   \   00000092   0xBD10             POP      {R4,PC}
    555                  } else if (x == 6) {
   \                     ??PWMC_ConfigureComparisonUnit_14:
   \   00000094   0x2806             CMP      R0,#+6
   \   00000096   0xD102             BNE.N    ??PWMC_ConfigureComparisonUnit_15
    556                      AT91C_BASE_PWMC->PWMC_CMP6MUPD = mode;
   \   00000098   0x66DA             STR      R2,[R3, #+108]
    557                      AT91C_BASE_PWMC->PWMC_CMP6VUPD = value;
   \   0000009A   0x6659             STR      R1,[R3, #+100]
   \   0000009C   0xBD10             POP      {R4,PC}
    558                  } else if (x == 7) {
   \                     ??PWMC_ConfigureComparisonUnit_15:
   \   0000009E   0x2807             CMP      R0,#+7
   \   000000A0   0xBF04             ITT      EQ 
   \   000000A2   0x67DA             STREQ    R2,[R3, #+124]
   \   000000A4   0x6759             STREQ    R1,[R3, #+116]
    559                      AT91C_BASE_PWMC->PWMC_CMP7MUPD = mode;
    560                      AT91C_BASE_PWMC->PWMC_CMP7VUPD = value;
    561                  }
    562              }
    563          }
   \                     ??PWMC_ConfigureComparisonUnit_8:
   \   000000A6   0xBD10             POP      {R4,PC}          ;; return
    564          
    565          //-----------------------------------------------------------------------------
    566          /// Configure event line mode.
    567          /// \param x    Line x
    568          /// \param mode Bitwise OR of line mode selection
    569          //-----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    570          void PWMC_ConfigureEventLineMode(unsigned int x, unsigned int mode)
    571          {
    572              if (x == 0) {
   \                     PWMC_ConfigureEventLineMode:
   \   00000000   0x....             LDR.N    R2,??DataTable23_18  ;; 0x4008c07c
   \   00000002   0xB908             CBNZ.N   R0,??PWMC_ConfigureEventLineMode_0
    573                  AT91C_BASE_PWMC->PWMC_EL0MR = mode;
   \   00000004   0x6011             STR      R1,[R2, #+0]
   \   00000006   0x4770             BX       LR
    574              } else if (x == 1) {
   \                     ??PWMC_ConfigureEventLineMode_0:
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??PWMC_ConfigureEventLineMode_1
    575                  AT91C_BASE_PWMC->PWMC_EL1MR = mode;
   \   0000000C   0x6051             STR      R1,[R2, #+4]
   \   0000000E   0x4770             BX       LR
    576              } else if (x == 2) {
   \                     ??PWMC_ConfigureEventLineMode_1:
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD101             BNE.N    ??PWMC_ConfigureEventLineMode_2
    577                  AT91C_BASE_PWMC->PWMC_EL2MR = mode;
   \   00000014   0x6091             STR      R1,[R2, #+8]
   \   00000016   0x4770             BX       LR
    578              } else if (x == 3) {
   \                     ??PWMC_ConfigureEventLineMode_2:
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD101             BNE.N    ??PWMC_ConfigureEventLineMode_3
    579                  AT91C_BASE_PWMC->PWMC_EL3MR = mode;
   \   0000001C   0x60D1             STR      R1,[R2, #+12]
   \   0000001E   0x4770             BX       LR
    580              } else if (x == 4) {
   \                     ??PWMC_ConfigureEventLineMode_3:
   \   00000020   0x2804             CMP      R0,#+4
   \   00000022   0xD101             BNE.N    ??PWMC_ConfigureEventLineMode_4
    581                  AT91C_BASE_PWMC->PWMC_EL4MR = mode;
   \   00000024   0x6111             STR      R1,[R2, #+16]
   \   00000026   0x4770             BX       LR
    582              } else if (x == 5) {
   \                     ??PWMC_ConfigureEventLineMode_4:
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD101             BNE.N    ??PWMC_ConfigureEventLineMode_5
    583                  AT91C_BASE_PWMC->PWMC_EL5MR = mode;
   \   0000002C   0x6151             STR      R1,[R2, #+20]
   \   0000002E   0x4770             BX       LR
    584              } else if (x == 6) {
   \                     ??PWMC_ConfigureEventLineMode_5:
   \   00000030   0x2806             CMP      R0,#+6
   \   00000032   0xD101             BNE.N    ??PWMC_ConfigureEventLineMode_6
    585                  AT91C_BASE_PWMC->PWMC_EL6MR = mode;
   \   00000034   0x6191             STR      R1,[R2, #+24]
   \   00000036   0x4770             BX       LR
    586              } else if (x == 7) {
   \                     ??PWMC_ConfigureEventLineMode_6:
   \   00000038   0x2807             CMP      R0,#+7
   \   0000003A   0xBF08             IT       EQ 
   \   0000003C   0x61D1             STREQ    R1,[R2, #+28]
    587                  AT91C_BASE_PWMC->PWMC_EL7MR = mode;
    588              }
    589          }
   \   0000003E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     `?<Constant {1, 2, 4, 8, 16, 32, 64, 128, 256, `

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x4008C008         DC32     0x4008c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x4008C200         DC32     0x4008c200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x4008C000         DC32     0x4008c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0x4008C00C         DC32     0x4008c00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x4008C020         DC32     0x4008c020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x4008C028         DC32     0x4008c028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x4008C004         DC32     0x4008c004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \   00000000   0x4008C010         DC32     0x4008c010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \   00000000   0x4008C014         DC32     0x4008c014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \   00000000   0x4008C044         DC32     0x4008c044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \   00000000   0x4008C04C         DC32     0x4008c04c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \   00000000   0x4008C050         DC32     0x4008c050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_13:
   \   00000000   0x4008C05C         DC32     0x4008c05c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_14:
   \   00000000   0x4008C064         DC32     0x4008c064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_15:
   \   00000000   0x4008C068         DC32     0x4008c068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_16:
   \   00000000   0x4008C06C         DC32     0x4008c06c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_17:
   \   00000000   0x4008C130         DC32     0x4008c130

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_18:
   \   00000000   0x4008C07C         DC32     0x4008c07c

   \                                 In section .rodata, align 4
   \                     `?<Constant {1, 2, 4, 8, 16, 32, 64, 128, 256, `:
   \   00000000   0x00000001         DC32 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024
   \              0x00000002   
   \              0x00000004   
   \              0x00000008   
   \              0x00000010   
   \              0x00000020   
   \              0x00000040   
   \              0x00000080   
   \              0x00000100   
   \              0x00000200   
   \              0x00000400   
   \   0000002C   0x2D 0x46          DC8 "-F- ASSERT: "
   \              0x2D 0x20    
   \              0x41 0x53    
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   00000039   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   0000003C   0x53 0x61          DC8 "Sanity check failed at %s:%d\012\015"
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x20 0x63    
   \              0x68 0x65    
   \              0x63 0x6B    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x61 0x74    
   \              0x20 0x25    
   \              0x73 0x3A    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   0000005B   0x00               DC8 0
   \   0000005C   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000064   0x5C 0x4D          DC8 5CH, 4DH, 61H, 72H, 74H, 69H, 6EH, 5CH
   \              0x61 0x72    
   \              0x74 0x69    
   \              0x6E 0x5C    
   \   0000006C   0x44 0x6F          DC8 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH, 74H
   \              0x63 0x75    
   \              0x6D 0x65    
   \              0x6E 0x74    
   \   00000074   0x73 0x5C          DC8 73H, 5CH, 41H, 74H, 6DH, 65H, 6CH, 41H
   \              0x41 0x74    
   \              0x6D 0x65    
   \              0x6C 0x41    
   \   0000007C   0x64 0x76          DC8 64H, 76H, 65H, 6EH, 74H, 75H, 72H, 65H
   \              0x65 0x6E    
   \              0x74 0x75    
   \              0x72 0x65    
   \   00000084   0x73 0x5C          DC8 73H, 5CH, 49H, 41H, 52H, 5CH, 61H, 72H
   \              0x49 0x41    
   \              0x52 0x5C    
   \              0x61 0x72    
   \   0000008C   0x6D 0x5C          DC8 6DH, 5CH, 65H, 78H, 61H, 6DH, 70H, 6CH
   \              0x65 0x78    
   \              0x61 0x6D    
   \              0x70 0x6C    
   \   00000094   0x65 0x73          DC8 65H, 73H, 5CH, 41H, 74H, 6DH, 65H, 6CH
   \              0x5C 0x41    
   \              0x74 0x6D    
   \              0x65 0x6C    
   \   0000009C   0x5C 0x61          DC8 5CH, 61H, 74H, 39H, 31H, 6CH, 69H, 62H
   \              0x74 0x39    
   \              0x31 0x6C    
   \              0x69 0x62    
   \   000000A4   0x5C 0x70          DC8 5CH, 70H, 65H, 72H, 69H, 70H, 68H, 65H
   \              0x65 0x72    
   \              0x69 0x70    
   \              0x68 0x65    
   \   000000AC   0x72 0x61          DC8 72H, 61H, 6CH, 73H, 5CH, 70H, 77H, 6DH
   \              0x6C 0x73    
   \              0x5C 0x70    
   \              0x77 0x6D    
   \   000000B4   0x63 0x5C          DC8 63H, 5CH, 70H, 77H, 6DH, 63H, 32H, 2EH
   \              0x70 0x77    
   \              0x6D 0x63    
   \              0x32 0x2E    
   \   000000BC   0x63 0x00          DC8 63H, 0
   \   000000BE   0x00 0x00          DC8 0, 0
   \   000000C0   0x2D 0x46          DC8 2DH, 46H, 2DH, 20H, 43H, 6FH, 75H, 6CH
   \              0x2D 0x20    
   \              0x43 0x6F    
   \              0x75 0x6C    
   \   000000C8   0x64 0x20          DC8 64H, 20H, 6EH, 6FH, 74H, 20H, 67H, 65H
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x67 0x65    
   \   000000D0   0x6E 0x65          DC8 6EH, 65H, 72H, 61H, 74H, 65H, 20H, 74H
   \              0x72 0x61    
   \              0x74 0x65    
   \              0x20 0x74    
   \   000000D8   0x68 0x65          DC8 68H, 65H, 20H, 64H, 65H, 73H, 69H, 72H
   \              0x20 0x64    
   \              0x65 0x73    
   \              0x69 0x72    
   \   000000E0   0x65 0x64          DC8 65H, 64H, 20H, 50H, 57H, 4DH, 20H, 66H
   \              0x20 0x50    
   \              0x57 0x4D    
   \              0x20 0x66    
   \   000000E8   0x72 0x65          DC8 72H, 65H, 71H, 75H, 65H, 6EH, 63H, 79H
   \              0x71 0x75    
   \              0x65 0x6E    
   \              0x63 0x79    
   \   000000F0   0x20 0x28          DC8 20H, 28H, 25H, 75H, 48H, 7AH, 29H, 0AH
   \              0x25 0x75    
   \              0x48 0x7A    
   \              0x29 0x0A    
   \   000000F8   0x0D 0x00          DC8 0DH, 0
   \   000000FA   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       64  FindClockConfiguration
             64 -> __aeabi_memcpy4
             64 -> printf
       16  PWMC_ConfigureChannel
             16 -> printf
       24  PWMC_ConfigureChannelExt
             24 -> printf
       32  PWMC_ConfigureClocks
             32 -> FindClockConfiguration
             32 -> printf
        8  PWMC_ConfigureComparisonUnit
        0  PWMC_ConfigureEventLineMode
        0  PWMC_ConfigureSyncChannel
        0  PWMC_DisableChannel
        0  PWMC_DisableChannelIt
        0  PWMC_DisableIt
        0  PWMC_DisableOverrideOutput
        0  PWMC_EnableChannel
        0  PWMC_EnableChannelIt
        0  PWMC_EnableFaultProtection
        0  PWMC_EnableIt
        0  PWMC_EnableOverrideOutput
        0  PWMC_FaultClear
       16  PWMC_SetDeadTime
             16 -> printf
        8  PWMC_SetDutyCycle
              8 -> printf
        0  PWMC_SetFaultMode
        0  PWMC_SetFaultProtectionValue
        0  PWMC_SetOverrideValue
        8  PWMC_SetPeriod
        0  PWMC_SetSyncChannelUpdatePeriod
        0  PWMC_SetSyncChannelUpdateUnlock
        8  PWMC_WriteBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     252  ?<Constant {1, 2, 4, 8, 16, 32, 64, 128, 256,
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_14
       4  ??DataTable23_15
       4  ??DataTable23_16
       4  ??DataTable23_17
       4  ??DataTable23_18
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
       6  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine2
      98  FindClockConfiguration
      94  PWMC_ConfigureChannel
     198  PWMC_ConfigureChannelExt
      96  PWMC_ConfigureClocks
     168  PWMC_ConfigureComparisonUnit
      64  PWMC_ConfigureEventLineMode
      12  PWMC_ConfigureSyncChannel
      12  PWMC_DisableChannel
      12  PWMC_DisableChannelIt
       2  PWMC_DisableIt
      12  PWMC_DisableOverrideOutput
      12  PWMC_EnableChannel
      12  PWMC_EnableChannelIt
       6  PWMC_EnableFaultProtection
       4  PWMC_EnableIt
      12  PWMC_EnableOverrideOutput
       6  PWMC_FaultClear
      76  PWMC_SetDeadTime
      50  PWMC_SetDutyCycle
       6  PWMC_SetFaultMode
       6  PWMC_SetFaultProtectionValue
       6  PWMC_SetOverrideValue
      30  PWMC_SetPeriod
      16  PWMC_SetSyncChannelUpdatePeriod
       8  PWMC_SetSyncChannelUpdateUnlock
      40  PWMC_WriteBuffer

 
   252 bytes in section .rodata
 1 160 bytes in section .text
 
 1 160 bytes of CODE  memory
   252 bytes of CONST memory

Errors: none
Warnings: none
